 /*  Student information for assignment:
 *
 *  UTEID:
 *  email address:
 *  Grader name:
 *  Number of slip days I am using:
 */


/*
 * Place results of experiments here:
 * 
 */


import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Random;

/**
 * Some test cases for CS314 Binary Search Tree assignment.
 *
 */
public class BSTTester {

    /**
     * The main method runs the tests.
     * @param args Not used
     */
	
	public static void main(String[] args) {
		leviTests();
		mikesTests();
		suhasTests();
		amirTests();
		zaydTests();
		matthewTests();
		
		divider("RESULTS");
		System.out.println("TOTAL TESTS: " + (numPassed + numFailed));
		System.out.println("NUM PASSED: " + numPassed);
		System.out.println("NUM FAILED: " + numFailed);
	}
	
	public static void leviTests() {
		BinarySearchTree<Integer> t = new BinarySearchTree<>();
		
		runTest(0.0, "Constructor", 0, t.size());
		runTest(0.1, "Constructor", false, t.remove(1));
		runTest(0.2, "Constructor", false, t.isPresent(1));
		runTest(0.3, "Constructor", "[]", t.getAll().toString());
		runTest(0.4, "Constructor", "[]", t.getAllLessThan(1).toString());
		runTest(0.5, "Constructor", "[]", t.getAllGreaterThan(1).toString());
		runTest(0.6, "Constructor", 0, t.numNodesAtDepth(0));
		
		t.add(0);
		
		runTest(1.0, "Add (Recursive)", 0, t.height());
		runTest(1.1, "Add (Recursive)", 1, t.size());
		runTest(1.2, "Add (Recursive)", 1, t.numNodesAtDepth(0));
		runTest(1.3, "Add (Recursive)", 0, t.getAll().get(0));
		
		
		for (int i = 1; i < 500; i++) {
			t.add(i);
		}
		
		runTest(1.4, "Add (Recursive)", 499, t.height());
		runTest(1.5, "Add (Recursive)", 500, t.size());
		runTest(1.6, "Add (Recursive)", 0, t.min());
		runTest(1.7, "Add (Recursive)", 499, t.max());
		runTest(1.8, "Add (Recursive)", 250, t.getAllLessThan(250).size());
		
		t = new BinarySearchTree<>();
		
		t.iterativeAdd(0);
		
		runTest(2.0, "Add (Iterative)", 0, t.height());
		runTest(2.1, "Add (Iterative)", 1, t.size());
		runTest(2.2, "Add (Iterative)", 1, t.numNodesAtDepth(0));
		runTest(2.3, "Add (Iterative)", 0, t.getAll().get(0));
		
		
		for (int i = 1; i < 500; i++) {
			t.iterativeAdd(i);
		}
		
		runTest(2.4, "Add (Iterative)", 499, t.height());
		runTest(2.5, "Add (Iterative)", 500, t.size());
		runTest(2.6, "Add (Iterative)", 0, t.min());
		runTest(2.7, "Add (Iterative)", 499, t.max());
		runTest(2.8, "Add (Iterative)", 250, t.getAllLessThan(250).size());
		
		for (int i = 1; i < 500; i++) {
			t.remove(i);
		}
		
		runTest(3.0, "Remove", 0, t.height());
		runTest(3.1, "Remove", 0, t.getAll().get(0));
		runTest(3.2, "Remove", true, t.remove(0));
		
		ArrayList<Integer> expected = new ArrayList<>();
		expected.add(-1);
		expected.add(5);
		expected.add(7);
		expected.add(10);
		expected.add(20);
		
		t.add(10);
		t.add(20);
		t.add(5);
		t.add(-1);
		t.add(7);
		t.add(8);
		
		runTest(3.3, "Remove", true, t.remove(8));
		runTest(3.4, "Remove", true, t.getAll().equals(expected));
		expected.remove(3);
		t.remove(10);
		runTest(3.5, "Remove", true, t.getAll().equals(expected));
		runTest(3.6, "Remove", expected.size(), t.size());
		
		expected = new ArrayList<>();
		t = new BinarySearchTree<>();
		
		runTest(4.0, "isPresent", false, t.isPresent(9));
		
		for (int i = 5; i > 0; i--) {
			t.add(i);
			expected.add(i);
		}
		
		for (int i = 1; i <= 5; i++) {
			runTest(4. + (i*1.0/10), "isPresent", true, t.isPresent(i));
		}
		
		expected = new ArrayList<>();
		t = new BinarySearchTree<>();
		
		expected.add(-1);
		expected.add(5);
		expected.add(7);
		expected.add(8);
		expected.add(10);
		expected.add(20);
		
		t.add(10);
		t.add(20);
		t.add(5);
		t.add(-1);
		t.add(7);
		t.add(8);
		
		runTest(4.6, "isPresent", true, t.isPresent(7));
		runTest(4.7, "isPresent", true, t.isPresent(8));
		runTest(4.8, "isPresent", true, t.isPresent(10));
		runTest(4.8, "isPresent", true, t.isPresent(-1));
		
		runTest(5.0, "Size", expected.size(), t.size());
		t.add(11);
		runTest(5.1, "Size", 7, t.size());
		t.remove(11);
		runTest(5.2, "Size", 6, t.size());
		
		runTest(6.0, "Height", 3, t.height());
		t.add(9);
		runTest(6.1, "Height", 4, t.height());
		t.remove(9);
		runTest(6.2, "Height", 3, t.height());
		
		runTest(7.0, "GetAll", expected, t.getAll());
		
		expected = new ArrayList<>();
		t = new BinarySearchTree<>();
		
		expected.add(-500);
		expected.add(9);
		expected.add(14);
		expected.add(900);
		expected.add(901);
		expected.add(1738);
		
		t.add(1738);
		t.add(14);
		t.add(-500);
		t.add(901);
		t.add(9);
		t.add(1738);
		t.add(900);
		t.add(901);
		
		runTest(7.1, "GetAll", expected, t.getAll());
		runTest(7.2, "GetAll", expected.size(), t.size());
		
		runTest(8.0, "max",1738, t.max());
		
		expected = new ArrayList<>();
		t = new BinarySearchTree<>();
		
		for (int i = 500; i >=0; i--) {
			t.add(i);
		}
		
		runTest(8.1, "max",500, t.max());
		runTest(9.0, "min",0, t.min());
		
		t = new BinarySearchTree<>();
		
		for (int i = 0; i <= 500; i++) {
			t.add(i);
		}
		
		runTest(9.1, "min", 0, t.min());
		runTest(8.2, "max", 500, t.max());
		
		for (int i = 500; i >0; i--) {
			t.remove(i);
		}
		
		runTest(9.2, "min", 0, t.min());
		
		expected = new ArrayList<>();
		t = new BinarySearchTree<>();
		
		expected.add(-1);
		expected.add(5);
		expected.add(7);
		expected.add(8);
		expected.add(10);
		expected.add(20);
		
		t.add(10);
		t.add(20);
		t.add(5);
		t.add(-1);
		t.add(7);
		t.add(8);
		
		for (int i = 0; i < expected.size(); i++) {
			runTest(10. + (i*1.0/10), "Get Kth", expected.get(i), t.get(i));
		}
		
		runTest(11.0, "getAllLessThan", expected, t.getAllLessThan(50000));
		runTest(11.1, "getAllLessThan", new ArrayList<Integer>(), t.getAllLessThan(-50000));
		
		expected = new ArrayList<>();
		expected.add(-1);
		expected.add(5);
		expected.add(7);
		expected.add(8);
		
		runTest(11.2, "getAllLessThan", expected, t.getAllLessThan(10));
		
		expected = new ArrayList<>();
		expected.add(-1);
		
		runTest(11.3, "getAllLessThan", expected, t.getAllLessThan(5));
		
		expected.add(5);
		expected.add(7);
		expected.add(8);
		expected.add(10);
		expected.add(20);
		
		runTest(12.0, "getAllGreaterThan", expected, t.getAllGreaterThan(-5000));
		runTest(12.1, "getAllGreaterThan", new ArrayList<Integer>(), t.getAllGreaterThan(50000));
		
		expected = new ArrayList<>();
		expected.add(8);
		expected.add(10);
		expected.add(20);
		
		runTest(12.2, "getAllGreaterThan", expected, t.getAllGreaterThan(7));
		
		expected.remove(0);
		expected.remove(0);
		
		runTest(12.0, "getAllGreaterThan", expected, t.getAllGreaterThan(12));
		
		runTest(13.0, "numNodesAtDepth", 1, t.numNodesAtDepth(0));
		runTest(13.1, "numNodesAtDepth", 2, t.numNodesAtDepth(1));
		runTest(13.2, "numNodesAtDepth", 2, t.numNodesAtDepth(2));
		runTest(13.3, "numNodesAtDepth", 1, t.numNodesAtDepth(3));
		runTest(13.4, "numNodesAtDepth", 0, t.numNodesAtDepth(4));

	}
	
	private static void runTest(double testNum, String testName, Object expected, Object actual) {
		System.out.printf("%-20s |    %-25s", "Test Number " + testNum, "Testing " + testName);

		if (expected.equals(actual)) {
			System.out.printf("%4s %20s\n", "|", "Test Passed");
			numPassed++;
		} else {
			System.out.printf("%20s \n\t %-20s %20s\n", "Test Failed.", "Expected " + expected.toString(),
					"Actual " + actual.toString());
			numFailed++;
		}
	}
	
    public static void mikesTests() {
        BinarySearchTree<String> t = new BinarySearchTree<>();

        //test 1
        System.out.println("Test 1: empty tree created.");
        showTestResults( t.size() == 0, 1 );

        //test 2
        System.out.println("Test 2: height of empty tree must be -1.");
        showTestResults( t.height() == -1, 2 );

        //test 3
        System.out.println("Test 3: empty tree must " +
        "not contain the String \"abyss\".");
        showTestResults( t.isPresent("abyss") == false, 3 );

        t.add("abyss");
        //test 4
        System.out.println("Test 4: added \"abyss\" to the" +
        "tree. Size must be 1.");       
        showTestResults( t.size() == 1, 4 );

        //test 5
        System.out.println("Test 5: height of tree with 1" +
        "element must be 0.");
        showTestResults( t.height() == 0, 5 );

        //test 6
        System.out.println("Test 6: \"abyss\" must be in the tree.");
        showTestResults( t.isPresent("abyss") == true, 6 );

        //test 7
        System.out.println("Test 7: tree must " +
        "not contain the String \"beep\".");        
        showTestResults( t.isPresent("beep") == false, 7);

        //test 8
        System.out.println("Test 8: min value must be" +
        "\"abyss\" at this point.");        
        showTestResults( t.min().equals("abyss"), 8);

        //test 9
        System.out.println("Test 9: max value must be" +
        "\"abyss\" at this point.");    
        showTestResults( t.max().equals("abyss"), 9);

        t.add("abyss");
        //test 10
        System.out.println("Test 10: attempt to add \"abyss\"" +
        "again. size must remain 1.");    
        showTestResults( t.size() == 1, 10 );

        //test 11
        System.out.println("Test 11: attempt to add \"abyss\"" +
        "again. height must remain 0.");  
        showTestResults( t.height() == 0, 11 );

        //test 12
        System.out.println("Test 12: \"abyss\" must still be" +
        "present.");  
        showTestResults( t.isPresent("abyss") == true, 12 );

        t.add("beep");
        //test 13
        System.out.println("Test 13: added \"beep\" to the" +
        "tree. Size must be 2.");           
        showTestResults( t.size() == 2, 13 );

        //test 14
        System.out.println("Test 14: height of tree with 2" +
        "elements must be 1."); 
        showTestResults( t.height() == 1, 14 );

        //test 15
        System.out.println("Test 15: Removing \"abyss\" from the tree.");
        showTestResults( t.remove("abyss") == true, 15 );

        //test 16
        System.out.println("Test 16: Removing \"beep\" from the tree.");
        showTestResults( t.remove("beep") == true, 16 );

        //test 17
        System.out.println("Test 17: Tree must be empty at this point.");
        showTestResults( t.size() == 0, 17 );

        t.add("beep");
        t.add("abyss");
        t.add("calls");
        ArrayList<String> expected = new ArrayList<>();
        expected.add("abyss");
        expected.add("beep");
        expected.add("calls");

        //test 18
        System.out.println("Test 18: Added \"beep\", \"abyss\", and" +
                "\"calls\" to the tree in that order.\n" +
        "Testing getAll method.");

        showTestResults( expected.equals( t.getAll() ) == true, 18 );

        //test 19
        t.add("bit");
        t.add("dish");
        System.out.println("Test 19: Added \"bit\" and \"dish\" to" +
        "tree. Checking that \"yes\" is not present.");     
        showTestResults( t.remove("yes") == false, 19);

        //test 20
        t.add("a");
        System.out.println("Test 20: Added \"a\" and then " +
        "removed it.");
        showTestResults(t.remove("a") == true, 20);

        //test 21
        System.out.println("Test 21: Checking that \"calls\" is still present.");
        showTestResults(t.remove("calls") == true, 21);

        //test 22
        t.remove("abyss");
        System.out.println("Test 22: Removing \"abyss\". " +
        "Checking that \"beep\" is still present.");
        showTestResults(t.remove("beep") == true, 22);

        // Test 23 - Adding unbalanced
        BinarySearchTree<Integer>  iTree = new BinarySearchTree<>();
        ArrayList<Integer> iExpected = new ArrayList<>();
        iTree.add(1);
        iTree.iterativeAdd(2);
        iTree.iterativeAdd(3);
        iTree.add(-1);
        iExpected.add(-1);
        iExpected.add(1);
        iExpected.add(2);
        iExpected.add(3);
        System.out.println("Test 23: Adding unbalanced");
        showTestResults( iExpected.equals( iTree.getAll() ) == true, 23 );
        //System.out.println(iTree.getAll());
        //iTree.printTree();

        // Test 24 - Adding unbalanced
        iTree.iterativeAdd(-2);
        iExpected.add(0, -2);
        System.out.println("Test 24: Adding unbalanced");
        showTestResults( iExpected.equals( iTree.getAll() ) == true, 24 );
        //System.out.println(iTree.getAll());
        //iTree.printTree();

        // Test 25 - Removing root [-2, -1, 2, 3]
        iTree.remove(1);
        iExpected.remove(new Integer(1));
        System.out.println("Test 25: Removing root");
        showTestResults( iExpected.equals( iTree.getAll() ) == true, 25 );
        //System.out.println(iTree.getAll());
        //iTree.printTree();

        // Test 26 - Removing new root [-2, 2, 3]
        iTree.remove(-1);
        iExpected.remove(new Integer(-1));
        System.out.println("Test 26: Removing new root");
        showTestResults( iExpected.equals( iTree.getAll() ) == true, 26 );
        //System.out.println(iTree.getAll());
        //iTree.printTree();

        // Test 27 - IsPresent new root
        System.out.println("Test 27: IsPresent new root");
        showTestResults( iTree.isPresent(-2) == true, 27 );
        //System.out.println(iTree.getAll());
        //iTree.printTree();

        // Test 28 - IsPresent rightmost minimum
        System.out.println("Test 28: IsPresent rightmost minimum");
        showTestResults( iTree.isPresent(2) == true, 28 );
        //System.out.println(iTree.getAll());
        //iTree.printTree();

        // Test 29 - Size
        System.out.println("Test 29: Size of tree");
        showTestResults( iTree.size() == 3, 29 );
        //System.out.println(iTree.getAll());
        //iTree.printTree();

        // Test 30 - Size removing rightmost minimum [-2, 3]
        iTree.remove(2);
        iExpected.remove(new Integer(2));
        System.out.println("Test 30: Size of tree");
        showTestResults( iTree.size() == 2, 30 );
        //System.out.println(iTree.getAll());
        //iTree.printTree();

        // Test 31 - Height
        System.out.println("Test 31: Height of tree");
        showTestResults( iTree.height() == 1, 31 );
        //System.out.println(iTree.getAll());
        //iTree.printTree();

        // Test 32 - Height removing root [3]
        iTree.remove(-2);
        iExpected.remove(new Integer(-2));
        System.out.println("Test 32: Height of tree");
        showTestResults( iTree.height() == 0, 32 );
        //System.out.println(iTree.getAll());
        //iTree.printTree();

        // Test 33 - Max of tree
        System.out.println("Test 33: Max of tree");
        showTestResults( iTree.max().equals(new Integer(3)), 33 );
        //System.out.println(iTree.getAll());
        //iTree.printTree();

        // Test 34 - Max of tree [-1, 3]
        iTree.add(-1);
        System.out.println("Test 34: Max of tree");
        showTestResults( iTree.max().equals(new Integer(3)), 34 );
        //System.out.println(iTree.getAll());
        //iTree.printTree();

        // Test 35 - Min of tree
        System.out.println("Test 35: Min of tree");
        showTestResults( iTree.min().equals(new Integer(-1)), 35 );
        //System.out.println(iTree.getAll());
        //iTree.printTree();

        // Test 36 - Min of tree
        iTree.add(4);
        System.out.println("Test 36: Min of tree");
        showTestResults( iTree.min().equals(new Integer(-1)), 36 );
        //System.out.println(iTree.getAll());
        //iTree.printTree();

        // Test 37 - Number of Nodes at Depth
        System.out.println("Test 37: Number of Nodes at depth of tree");
        showTestResults( iTree.numNodesAtDepth(0) == 1, 37 );
        //System.out.println(iTree.getAll());
        //iTree.printTree();

        // Test 38 - Number of Nodes at Depth
        System.out.println("Test 38: Number of Nodes at depth of tree");
        showTestResults( iTree.numNodesAtDepth(1) == 2, 38 );
        //System.out.println(iTree.getAll());
        //iTree.printTree();

        // Test 39 - height
        int[] values = {50, 25, -10, 10, 5, 0, 23, 30, 35, 40, 100, 75, 200};
        BinarySearchTree<Integer> t2 = new BinarySearchTree<>();
        for(int i : values)
            t2.add(i);
        System.out.println("Height again for non trivial tree");
        showTestResults(t2.height() == 5, 39);
        //System.out.println(t2.getAll());
        //t2.printTree();

        // Test 40 - 52: get kth
        System.out.println("getKth");
        Arrays.sort(values);
        System.out.println(t2.getAll());
        for(int i = 0; i < values.length; i++) {
            showTestResults(t2.get(i).equals(new Integer(values[i])), 40 + i);
        }

        // Test 53: getAllLessThan
        System.out.println("get all less than -50");
        showTestResults(t2.getAllLessThan(-50).equals(new ArrayList<Integer>()), 53);
        //System.out.println(t2.getAll());
        //t2.printTree();


        // Test 54: getAllLessThan
        System.out.println("get all less than 25");
        ArrayList<Integer> expectedList = new ArrayList<>();
        int cutoff = 25;
        int index = 0;
        while(index < values.length && values[index] < cutoff) {
            expectedList.add(values[index]);
            index++;
        }
        List<Integer> actual = t2.getAllLessThan(cutoff);    
        showTestResults(actual.equals(expectedList), 54);
        //System.out.println(t2.getAll());
        //t2.printTree();

        // Test 55: getAllLessThan
        System.out.println("get all less than 1000");
        expectedList.clear();
        cutoff = 1000;
        index = 0;
        while(index < values.length && values[index] < cutoff) {
            expectedList.add(values[index]);
            index++;
        }
        actual = t2.getAllLessThan(cutoff);    
        showTestResults(actual.equals(expectedList), 55);
        System.out.println("expected list: " + expectedList);
        System.out.println("actual list:   " + actual);
        //System.out.println(expectedList);
        //System.out.println(t2.getAll());
        //t2.printTree();


        // Test 57: getAllGreaterThan
        System.out.println("get all greater than 1000");
        expectedList.clear();
        cutoff = 1000;
        index = values.length - 1;
        while(index >= 0 && values[index] > cutoff) {
            expectedList.add(values[index]);
            index--;
        }
        Collections.reverse(expectedList);
        actual = t2.getAllGreaterThan(cutoff);    
        showTestResults(actual.equals(expectedList), 57);
        //System.out.println(expectedList);
        //System.out.println(t2.getAll());
        //t2.printTree();

        // Test 58: getAllGreaterThan
        System.out.println("get all greater than 25");
        expectedList.clear();
        cutoff = 25;
        index = values.length - 1;
        while(index >= 0 && values[index] > cutoff) {
            expectedList.add(values[index]);
            index--;
        }
        Collections.reverse(expectedList);
        actual = t2.getAllGreaterThan(cutoff);    
        showTestResults(actual.equals(expectedList), 58);
        System.out.println("expected list: " + expectedList);
        System.out.println("actual list:   " + actual);
        //t2.printTree();


        // Test 59: getAllGreaterThan
        System.out.println("get all greater than -1000");
        expectedList.clear();
        cutoff = -1000;
        index = values.length - 1;
        while(index >= 0 && values[index] > cutoff) {
            expectedList.add(values[index]);
            index--;
        }
        Collections.reverse(expectedList);
        actual = t2.getAllGreaterThan(cutoff);    
        showTestResults(actual.equals(expectedList), 59);
        System.out.println("expected list: " + expectedList);
        System.out.println("actual list:   " + actual);
        //t2.printTree();
          
        /*
        // Test 60, stress test
        System.out.println("Stress test, comparing size to HashSet");
        BinarySearchTree<Integer> bst1 = new BinarySearchTree<>();
        HashSet<Integer> hs = new HashSet<>();
        Random r = new Random();
        int numValues = 500000;
        for(int i = 0; i < numValues; i++) {
            int temp = r.nextInt();
            bst1.add(temp);
            hs.add(temp);
        }
        showTestResults(hs.size() == bst1.size(), 60);
        
        // Test 61, stress test
        System.out.println("Stress test, comparing size to HashSet");
        bst1 = new BinarySearchTree<>();
        hs = new HashSet<>();
        numValues = 1000000;
        for(int i = 0; i < numValues; i++) {
            int temp = r.nextInt();
            bst1.add(temp);
            hs.add(temp);
        }
        showTestResults(hs.size() == bst1.size(), 61);
        */
    }
    
    
    
    
    
    //Important note: depending on how you do your remove method (find max of left subtree or find min of right subtree, you **might** fail some test cases (I am unsure of this). I had implemented it by finding max of left subtree which I assume is what most people did.
    private static void suhasTests() {
        BinarySearchTree<Integer> tree = new BinarySearchTree<>();
        BinarySearchTree<Integer> empty = new BinarySearchTree<>();
        BinarySearchTree<Integer> test = new BinarySearchTree<>();

        testRun(tree.size(), 0, "empty tree size", 0.1);
        testRun(tree.height(), -1, "empty tree height", 0.2);
        System.out.println();

        testRun(tree.add(6), true, "add method (return value)", 1.1);
        testRun(tree.size(), 1, "add method (size)", 1.2);
        testRun(tree.height(), 0, "add method (height)", 1.3);
        testRun(tree.add(6), false, "add method (return value)", 1.4);
        testRun(tree.size(), 1, "add method (size)", 1.5);
        testRun(tree.height(), 0, "add method (height)", 1.6);
        System.out.println();

        tree.add(2);
        tree.add(10);
        testRun(tree.remove(6), true, "remove method (return value)", 2.1);
        testRun(tree.remove(9), false, "remove method (return value)", 2.2);
        testRun(tree.size(), 2, "remove method (size)", 2.3);
        testRun(tree.height(), 1, "remove method (height)", 2.4);
        System.out.println();

        testRun(tree.isPresent(6), false, "isPresent method", 3.1);
        testRun(tree.isPresent(2), true, "isPresent method", 3.2);
        testRun(tree.isPresent(10), true, "isPresent method", 3.3);
        testRun(empty.isPresent(0), false, "isPresent method (empty tree)", 3.4);
        System.out.println();

        tree.add(100);
        tree.add(4);
        tree.add(-5);
        testRun(tree.size(), 5, "size method", 4.1);
        testRun(empty.size(), 0, "size method (empty tree)", 4.2);
        System.out.println();
        
        testRun(tree.height(), 2, "height method", 5.1);
        tree.remove(10);
        testRun(tree.height(), 2, "height method", 5.2);
        System.out.println();
        
        testRun(empty.getAll(), new ArrayList<Integer>(), "getAll method (empty tree)", 6.1);
        List<Integer> expected = new ArrayList<Integer>();
        expected.add(-5);
        expected.add(2);
        expected.add(4);
        expected.add(100);
        testRun(tree.getAll(), expected, "getAll method", 6.2);
        tree.add(10);
        expected.add(3, 10);
        testRun(tree.getAll(), expected, "getAll method", 6.3);
        
        for(int i = 0; i <= 100; i++) {
            test.add(i);
            test.add(200 - i);
        }
        expected.clear();
        for(int i = 0; i <= 200; i++) {
            expected.add(i);
        }
        testRun(test.getAll(), expected, "getAll method", 6.4);
        System.out.println();
        
        empty.add(0);
        
        testRun(tree.max(), 100, "max method", 7.1);
        testRun(test.max(), 200, "max method", 7.2);
        testRun(empty.max(), 0, "max method (only one element)", 7.3);
        System.out.println();
        
        testRun(tree.min(), -5, "min method", 8.1);
        testRun(test.min(), 0, "min method", 8.2);
        testRun(empty.min(), 0, "min method (only one element)", 8.3);
        System.out.println();
        
        empty.remove(0);
        
        testRun(tree.iterativeAdd(-2), true, "iterativeAdd method (return value)", 9.1);
        testRun(tree.size(), 6, "iterativeAdd method (size)", 9.2);
        testRun(tree.height(), 3, "iterativeAdd method (height)", 9.3);
        testRun(tree.iterativeAdd(4), false, "iterativeAdd method (return value)", 9.4);
        testRun(tree.size(), 6, "iterativeAdd method (size)", 9.5);
        testRun(tree.height(), 3, "iterativeAdd method (height)", 9.6);
        System.out.println();
        
        testRun(tree.get(0), -5, "get method (smallest)", 10.1);
        testRun(tree.get(5), 100, "get method (largest)", 10.2);
        testRun(tree.get(3), 4, "get method (random)", 10.3);
        
        boolean wrong = false;
        for(int i = 0; i <= 200 && !wrong; i++) {
            if(test.get(i) != i)
                wrong = true;
        }
        testRun(wrong, false, "get method (200 values)", 10.4);
        System.out.println();
        
        tree.add(3);
        tree.add(-8);
        tree.add(0);
        tree.add(150);
        
        expected.clear();
        testRun(tree.getAllLessThan(-10), expected, "getAllLessThan method (smaller than min)", 11.1);
        expected = tree.getAll();
        testRun(tree.getAllLessThan(200), expected, "getAllLessThan method (greater than max)", 11.2);
        expected.clear();
        expected.add(-8);
        expected.add(-5);
        expected.add(-2);
        expected.add(0);
        testRun(tree.getAllLessThan(2), expected, "getAllLessThan method (random)", 11.3);
        expected.clear();
        System.out.println();
        
        expected.clear();
        testRun(tree.getAllGreaterThan(200), expected, "getAllGreaterThan method (greater than max)", 12.1);
        expected = tree.getAll();
        testRun(tree.getAllGreaterThan(-10), expected, "getAllGreaterThan method (smaller than min)", 12.2);
        expected.clear();
        expected.add(0);
        expected.add(2);
        expected.add(3);
        expected.add(4);
        expected.add(10);
        expected.add(100);
        expected.add(150);
        testRun(tree.getAllGreaterThan(-2), expected, "getAllGreaterThan method (random)", 12.3);
        expected.clear();
        System.out.println();
        
        testRun(tree.numNodesAtDepth(0), 1, "numNodesAtDepth (only root at depth 0)", 13.1);
        testRun(tree.numNodesAtDepth(4), 0, "numNodesAtDepth (no nodes at depth 4)", 13.2);
        testRun(tree.numNodesAtDepth(3), 3, "numNodesAtDepth", 13.3);
        testRun(test.numNodesAtDepth(200), 1, "numNodesAtDepth", 13.4);
    }

    private static void testRun(Object actual, Object expected, String print, double testNum) {
        String result = null;
        if (actual.equals(expected)) {
        		numPassed++;
            result = "Passed";
        } else {
        		numFailed++;
            result = "\n***FAILED***";
        }
        System.out.println(result + " test " + testNum + ": " + print);
        if (result.equals("\n***FAILED***")) {
            System.out.println("   Actual : " + actual + ", Expected : " + expected + "\n");
        }
    }
    
    
    
    
    
    
    private static void amirTests() {
		BinarySearchTree<Integer> tree1 = new BinarySearchTree<>();
		ArrayList<Integer> expectedIntList = new ArrayList<>();


		System.out.println("Test 1 - add():");
		System.out.println("1.0 - Testing the return value of add");
		showTestResults(tree1.add(10) == true, 1.0);
		System.out.println("1.1 - Testing the size after add");
		showTestResults(tree1.size() == 1, 1.1);
		System.out.println("1.2 - Testing the tree list after add");
		expectedIntList.add(10);
		showTestResults(tree1.getAll().equals(expectedIntList), 1.2);
		System.out.println("1.3 - Testing the return value of add when adding a duplicate");
		showTestResults(tree1.add(10) == false, 1.3);
		System.out.println("1.4 - Testing the size after add when adding a duplicate");
		showTestResults(tree1.size() == 1, 1.4);
		System.out.println("1.5 - Testing the tree list after add when adding a duplicate");
		showTestResults(tree1.getAll().equals(expectedIntList), 1.5);
		System.out.println();

		System.out.println("Test 2 - add():");
		System.out.println("2.0 - Testing the return value of add");
		showTestResults(tree1.add(5) == true, 2.0);
		System.out.println("2.1 - Testing the size after add");
		showTestResults(tree1.size() == 2, 2.1);
		System.out.println("2.2 - Testing the tree list after add");
		expectedIntList.add(0, 5);
		showTestResults(tree1.getAll().equals(expectedIntList), 2.2);
		System.out.println();
		System.out.println();

		// Alter tree1 for next tests
		addSomeValsToTheTree1(tree1, expectedIntList);
		//** Tree1 so far: [-10, -5, 0, 2, 5, 8, 10, 12, 15, 20], size: 10 **

		System.out.println("Test 3 - remove():");
		System.out.println("Removing the root...");
		System.out.println("3.0 - Testing the return value of remove");
		showTestResults(tree1.remove(10) == true, 3.0);
		System.out.println("3.1 - Testing the size after remove");
		showTestResults(tree1.size() == 9, 3.1);
		System.out.println("3.2 - Testing the tree list after remove");
		expectedIntList.remove(6);
		showTestResults(tree1.getAll().equals(expectedIntList), 3.2);
		System.out.println();

		System.out.println("Test 4 - remove():");
		System.out.println("Removing a value that is not present...");
		System.out.println("4.0 - Testing the return value of remove");
		showTestResults(tree1.remove(25) == false, 4.0);
		System.out.println("4.1 - Testing the size after remove");
		showTestResults(tree1.size() == 9, 4.1);
		System.out.println("4.2 - Testing the tree list after remove");
		showTestResults(tree1.getAll().equals(expectedIntList), 4.2);
		System.out.println();
		System.out.println();

		//** Tree1 so far: [-10, -5, 0, 2, 5, 8, 12, 15, 20], size: 9 **

		System.out.println("Test 5 - isPresent():");
		System.out.println("5.0 - Value is not present");
		showTestResults(tree1.isPresent(10) == false, 5.0);
		System.out.println();

		System.out.println("Test 6 - isPresent():");
		System.out.println("6.0 - Value is present");
		showTestResults(tree1.isPresent(-10) == true, 6.0);
		System.out.println();
		System.out.println();

		System.out.println("Test 7 - size()");
		showTestResults(tree1.size() == 9, 7);
		System.out.println();

		BinarySearchTree<String> tree2 = new BinarySearchTree<>();
		System.out.println("Test 8 - size()");
		showTestResults(tree2.size() == 0, 8);
		System.out.println();
		System.out.println();


		System.out.println("Test 9 - height()");
		showTestResults(tree2.height() == -1, 9);
		System.out.println();

		System.out.println("Test 10 - height()");
		showTestResults(tree1.height() == 4, 10);
		System.out.println();
		System.out.println();

		ArrayList<String> expectedStringList = new ArrayList<>();
		// Alter tree2 for next tests
		addSomeValsToTheTree2(tree2, expectedStringList);
		//** Tree2 so far: [A, C, H, M, O, Y, Z], size: 7 **


		System.out.println("Test 11 - getAll()");
		showTestResults(tree2.getAll().equals(expectedStringList), 11);
		System.out.println();

		System.out.println("Test 12 - getAll()");
		showTestResults(tree1.getAll().equals(expectedIntList), 12);
		System.out.println();
		System.out.println();


		System.out.println("Test 13 - max()");
		showTestResults(tree2.max().equals("Z"), 13);
		System.out.println();

		System.out.println("Test 14 - max()");
		showTestResults(tree1.max().equals(20), 14);
		System.out.println();
		System.out.println();

		System.out.println("Test 15 - min()");
		showTestResults(tree2.min().equals("A"), 15);
		System.out.println();

		System.out.println("Test 16 - min()");
		showTestResults(tree1.min() == -10, 16);
		System.out.println();
		System.out.println();

		System.out.println("Test 17 - iterativeAdd():");
		System.out.println("Value not present...");
		System.out.println("17.0 - Testing the return value of iterativeAdd");
		showTestResults(tree1.iterativeAdd(10) == true, 17.0);
		System.out.println("17.1 - Testing the size after add");
		showTestResults(tree1.size() == 10, 17.1);
		System.out.println("17.2 - Testing the tree list after add");
		expectedIntList.add(10);
		Collections.sort(expectedIntList);
		showTestResults(tree1.getAll().equals(expectedIntList), 17.2);
		System.out.println();

		System.out.println("Test 18 - iterativeAdd():");
		System.out.println("Value already present...");
		System.out.println("18.0 - Testing the return value of add when adding a duplicate");
		showTestResults(tree1.add(10) == false, 18.0);
		System.out.println("18.1 - Testing the size after add when adding a duplicate");
		showTestResults(tree1.size() == 10, 18.1);
		System.out.println("18.2 - Testing the tree list after add when adding a duplicate");
		showTestResults(tree1.getAll().equals(expectedIntList), 18.2);
		System.out.println();
		System.out.println();

		//** Tree1 so far: [-10, -5, 0, 2, 5, 8, 10, 12, 15, 20], size: 10 **

		System.out.println("Test 19 - get()");
		showTestResults(tree1.get(4) == 5, 19);
		System.out.println();

		System.out.println("Test 20 - get()");
		showTestResults(tree2.get(0).equals("A"), 20);
		System.out.println();
		System.out.println();

		System.out.println("Test 21 - getAllLessThan()");
		showTestResults(tree1.getAllLessThan(-10).equals(expectedIntList.subList(0, 0)), 21);
		System.out.println();

		System.out.println("Test 22 - getAllLessThan()");
		showTestResults(tree2.getAllLessThan("O").equals(expectedStringList.subList(0, 4)), 22);
		System.out.println();
		System.out.println();

		System.out.println("Test 23 - getAllGreaterThan()");
		showTestResults(tree2.getAllGreaterThan("O").equals(expectedStringList.subList(5, 7)), 23);
		System.out.println();

		System.out.println("Test 24 - getAllGreaterThan()");
		showTestResults(tree1.getAllGreaterThan(20).equals(expectedIntList.subList(7, 7)), 24);
		System.out.println();
		System.out.println();

		//** Tree1 so far: [-10, -5, 0, 2, 5, 8, 10, 12, 15, 20], size: 10 **
		//** Tree2 so far: [A, C, H, M, O, Y, Z], size: 7 **

		System.out.println("Test 25 - numNodesAtDepth()");
		showTestResults(tree1.numNodesAtDepth(2) == 3, 25);
		System.out.println();

		System.out.println("Test 26 - numNodesAtDepth()");
		showTestResults(tree1.numNodesAtDepth(5) == 0, 26);
		System.out.println();

		System.out.println("Test 27 - numNodesAtDepth()");
		showTestResults(tree1.numNodesAtDepth(0) == 1, 27);
		System.out.println();

		System.out.println("Test 28 - numNodesAtDepth()");
		showTestResults(tree1.numNodesAtDepth(3) == 3, 28);
		System.out.println();

	}

	private static void addSomeValsToTheTree1(BinarySearchTree<Integer> tree, ArrayList<Integer> expected) {
		int[] vals = {15, 12, 8, 0, -10, -5, 2, 20};
		for(int value: vals) {
			tree.add(value);
			expected.add(value);
		}
		Collections.sort(expected);
	}

	private static void addSomeValsToTheTree2(BinarySearchTree<String> tree, ArrayList<String> expected) {
		String[] vals = {"O", "A", "H", "M", "C", "Z", "Y"};
		for(String value: vals) {
			tree.add(value);
			expected.add(value);
		}
		Collections.sort(expected);
	}

	private static void showTestResults(boolean passed, double testNum) {

		if( passed ) {
			System.out.println( "Test " + testNum + " passed.");
			numPassed++;
		}
		else {
			System.out.println( "TEST " + testNum + " ***FAILED***.");
			numFailed++;
		}
	}
	
	
	
	
	
	
	
	private static final String ADD = "add";
	  private static final String GET = "get";
	  private static final String ALL = "getAll";
	  private static final String GRE = "getAllGreaterThan";
	  private static final String LES = "getAllLessThan";
	  private static final String HEIGHT = "height";
	  private static final String ISPR = "isPresent";
	  private static final String ITA = "iterativeAdd";
	  private static final String MAX = "max";
	  private static final String MIN = "min";
	  private static final String DEP = "numNodesAtDepth";
	  private static final String REM = "remove";
	  private static final String SIZE = "size";
	  private static String currentTest = "";
	  private static int testNum = 1;
	  /**
	   * The main method runs the tests.
	   * @param args Not used
	   */
	  public static void zaydTests() {
	    BinarySearchTree<Integer> b = new BinarySearchTree<>();

	    divider(ADD);
	    printResult(b.add(12), true);
	    printResult(b.add(12), false);

	    divider(GET);
	    printResult(b.get(0), 12);
	    b.add(15);
	    printResult(b.get(1), 15);

	    divider(ALL);
	    printResult(b.getAll().toString(), "[12, 15]");
	    b.remove(12);
	    printResult(b.getAll().toString(), "[15]");

	    divider(GRE);
	    b.add(-1);
	    b.add(2);
	    printResult(b.getAllGreaterThan(1).toString(), "[2, 15]");
	    printResult(b.getAllGreaterThan(15).toString(), "[]");

	    divider(LES);
	    printResult(b.getAllLessThan(1).toString(), "[-1]");
	    printResult(b.getAllLessThan(10).toString(), "[-1, 2]");

	    divider(HEIGHT);
	    printResult(b.height(), 2);
	    b.remove(-1);
	    printResult(b.height(), 1);

	    divider(ISPR);
	    printResult(b.isPresent(-1), false);
	    printResult(b.isPresent(15), true);

	    divider(ITA);
	    printResult(b.iterativeAdd(1), true);
	    printResult(b.iterativeAdd(15), false);

	    divider(MAX);
	    printResult(b.max(), 15);
	    b.remove(15);
	    printResult(b.max(), 2);

	    divider(MIN);
	    printResult(b.min(), 1);
	    b.add(0);
	    printResult(b.min(), 0);

	    divider(DEP);
	    printResult(b.numNodesAtDepth(0), 1);
	    printResult(b.numNodesAtDepth(3), 0);

	    divider(REM);
	    printResult(b.remove(0), true);
	    printResult(b.remove(0), false);

	    divider(SIZE);
	    printResult(b.size(), 2);
	    b.add(1);
	    b.add(15);
	    printResult(b.size(), 3);
	  }


	  private static void printResult(Object actual, Object expected) {
	    if (actual == null) {
	      actual = "null";
	    }
	    if (expected instanceof String && !(actual instanceof String)) {
	      actual = actual.toString();
	    }
	    System.out.print("Test number " + testNum + ": testing " + currentTest + " - ");
	    String result = actual.equals(expected) ? "PASSED" : "*** FAILED ***";
	    System.out.print(result + " test " + testNum + "\n");
	    if (result.equals("*** FAILED ***")) {
	    	  numFailed++;
	      System.out.println("   *** Actual: " + actual + " Expected: " + expected);
	    } else {
	    	  numPassed++;
	    }
	    testNum++;
	  }
	  
	  
	  
	  private static int numPassed = 0;
		private static int numFailed = 0;
		/**
		 * The main method runs the tests.
		 * 
		 * @param args
		 *            Not used
		 */
		public static void matthewTests() {
			BinarySearchTree<String> t = new BinarySearchTree<>();
			BinarySearchTree<Integer> t1 = new BinarySearchTree<>();
			int testNum = 1;
			
			divider("CONSTRUCTOR");
			// test 1:
			printTestInfo("Default Constructor, size == 0", testNum);
			showTestResults(t.size() == 0, testNum);
			testNum++;
			
			// test 2:
			printTestInfo("Default Constructor, numNodesAtDepth == 0", testNum);
			showTestResults(t.numNodesAtDepth(5) == 0, testNum);
			testNum++;
			
			divider("ADD");
			// test 3:
			String truth = "Assignment 9 is better than Assignment 8";
			t.add(truth);
			printTestInfo("Add one element. Height = 0", testNum);
			showTestResults(t.height() == 0, testNum);
			testNum++;
			
			// test 4:
			printTestInfo("Add one element. Size = 1", testNum);
			showTestResults(t.size() == 1, testNum);
			testNum++;
			
			// test 5:
			printTestInfo("Add one element, isPresent", testNum);
			showTestResults(t.isPresent(truth), testNum);
			testNum++;
			
			divider("REMOVE");
			// test 6: 
			printTestInfo("Remove element not in list = false", testNum);
			showTestResults(!t.remove("a8>a9"), testNum);
			testNum++;
			
			// test 7: 
			printTestInfo("Remove element in list.", testNum);
			showTestResults(t.remove(truth), testNum);
			testNum++;
			
			// test 8: 
			printTestInfo("Height = -1 after removing only element", testNum);
			showTestResults(t.height() == -1, testNum);
			testNum++;
			
			divider("isPresent");
			// test 9:
			t.add("67oI");
			truth = "67oI";
			printTestInfo("isPresent: adding element and check", testNum);
			showTestResults(t.isPresent(truth), testNum);
			testNum++;
			
			// test 10: 
			truth = truth.toLowerCase();
			printTestInfo("isPresent: isPresent is case sensitive", testNum);
			showTestResults(!t.isPresent(truth), testNum);
			testNum++;
			
			divider("size");
			// test 11: 
			printTestInfo("Size", testNum);
			showTestResults(t.size() == 1, testNum);
			testNum++;

			// test 12:
			t.add("hi");
			String greeting = "hi";
			t.add(greeting);
			printTestInfo("Size: adding duplicate element should not affect size", testNum);
			showTestResults(t.size() == 2, testNum);
			testNum++;
			
			divider("HEIGHT");
			// test 13:
			printTestInfo("Height on tree with 2 elements", testNum);
			showTestResults(t.height() == 1, testNum);
			testNum++;
			
			
			// test 14:
			ArrayList<Integer> numbers = new ArrayList<>();
			for (int i = 0; i < 10; i++) {
				numbers.add(i);
				t1.add(i);
			}
			printTestInfo("Height: Adding ten elements to empty tree in ascending order", testNum);
			showTestResults(t1.height() == 9, testNum);
			testNum++;
			
			// test 15:
			t1.remove(0);
			t1.remove(9);
			printTestInfo("Height: Removing root and leaf node", testNum);
			showTestResults(t1.height() == 7, testNum);
			testNum++;
			
			divider("GETALL");
			// test 16:
			t1.add(0);
			t1.add(9);
			List<Integer> treeList = t1.getAll();
			printTestInfo("GetAll: list.size() == bst.size()", testNum);
			showTestResults(treeList.size() == t1.size(), testNum);
			testNum++;
			
			// test 17:
			printTestInfo("GetAll: List is in ascending order", testNum);
			showTestResults(treeList.equals(numbers), testNum);
			testNum++;
			
			divider("MAX");
			
			// test 18: 
			t1.add(1000);
			printTestInfo("Max element", testNum);
			showTestResults(t1.max() == 1000, testNum);
			testNum++;
			
			// test 19: 
			t1.remove(1000);
			printTestInfo("Max element after removing max.", testNum);
			showTestResults(t1.max() != 1000, testNum);
			testNum++;
			
			divider("MIN");
			// test 20: 
			printTestInfo("Min element", testNum);
			showTestResults(t1.min() == 0, testNum);
			testNum++;
			
			// test 21: 
			t1.add(-50);
			printTestInfo("New minimum element after adding value < last min", testNum);
			showTestResults(t1.min() == -50, testNum);
			testNum++;
			
			divider("iterativeAdd");
			t1 = new BinarySearchTree<Integer>();
			numbers.clear();
			
			for (int i = 0; i < 10; i++) {
				int numToAdd = i % 2 == 0 ? 3*i : -4*i;
				t1.iterativeAdd(numToAdd);
				numbers.add(numToAdd);	
			}
			Collections.sort(numbers);
			treeList = t1.getAll();
			
			// test 22:
			printTestInfo("IterativeAdd 10 elements. Size", testNum);
			showTestResults(t1.size() == 10, testNum);
			testNum++;
			
			// test 23:
			printTestInfo("IterativeAdd: elements in order", testNum);
			showTestResults(treeList.equals(numbers), testNum);
			testNum++;
			
			divider("get(kth)");
			// test 24:
			printTestInfo("get(kth): get(0) is min", testNum);
			showTestResults(t1.get(0) == t1.min(), testNum);
			testNum++;
			
			// test 25: 
			printTestInfo("get(kth): get(size-1) is max", testNum);
			showTestResults(t1.get(t1.size() - 1) == t1.max(), testNum);
			testNum++;
			
			divider("getAllLessThan");
			t1 = new BinarySearchTree<Integer>();
			numbers.clear();
			
			
			// Adding random values to tree and arrayLists.
			ArrayList<Integer> numbers1 = new ArrayList<>();
			Random r = new Random();
			for (int i = 0; i < 1000; i++) {
				int randInt = r.nextInt(5000);
				t1.add(randInt);
				if (!numbers.contains(randInt) && randInt < 2500)
					numbers.add(randInt);
				if (!numbers1.contains(randInt) && randInt > 2500)
					numbers1.add(randInt);
			}
			Collections.sort(numbers);
			Collections.sort(numbers1);
			List<Integer> lessList = t1.getAllLessThan(2500);
			List<Integer> greaterList = t1.getAllGreaterThan(2500);
			
			// test 26: 
			printTestInfo("getAllLessThan: all lesser elements in list", testNum);
			showTestResults(lessList.equals(numbers), testNum);
			testNum++;
			
			// test 27: 
			printTestInfo("getAllLessThan: contains min element", testNum);
			showTestResults(lessList.contains(t1.min()), testNum);
			testNum++;
			
			divider("getAllGreaterThan");
			// test 28: 
			printTestInfo("getAllGreaterThan: all greater elements in list", testNum);
			showTestResults(greaterList.equals(numbers1), testNum);
			testNum++;
			
			// test 29: 
			printTestInfo("getAllGreaterThan: contains max element", testNum);
			showTestResults(greaterList.contains(t1.max()), testNum);
			testNum++;
			
			divider("numNodesAtDepth");
			
			// test 30:
			printTestInfo("numNodesAtDepth: depth 0 returns 1 (root)", testNum);
			showTestResults(t1.numNodesAtDepth(0) == 1, testNum);
			testNum++;
			// test 31:
			t1 = new BinarySearchTree<Integer>();
			t1.add(5);
			t1.add(6);
			t1.add(7);
			printTestInfo("numNodesAtDepth: root with one child", testNum);
			showTestResults(t1.numNodesAtDepth(1) == 1, testNum);
						

		}

		private static void showTestResults(boolean passed, int testNum) {
			if (passed) {
				System.out.println("Test " + testNum + " passed.");
				numPassed++;
			}
			else {
				System.out.println("TEST " + testNum + " FAILED.");
				numFailed++;
			}
				
		}
		
		private static void printTestInfo(String info, int testNum) {
			System.out.println("Test " + testNum + ": " + info);
		}
		
		private static void divider(String methodInTesting) {
			System.out.println("\n*************** " + methodInTesting + " ***************\n");
		}
}